![image](https://user-images.githubusercontent.com/72671239/223050807-b52eb062-3ba4-40aa-80d2-3cdff12fa39c.png)

## who chooses the tls version that will be used during the connection? the client or the server
The TLS version that will be used during a connection is typically negotiated by the client and server during the TLS handshake process. The client initiates the TLS handshake by sending a `ClientHello` message to the server, which includes the highest TLS version it supports. The server responds with a `ServerHello` message, which **includes the TLS version that will be used for the connection**. If the server supports the TLS version specified by the client, it will use that version; otherwise, **it will select the highest TLS version that both the client and server support.**

In general, both the client and server have a say in which TLS version is used, but the final decision is ultimately made by the server based on the TLS version options provided by the client.

### what is the content of the clienthello
The `ClientHello` message is the first message sent by a client in the TLS handshake process. It is used to initiate a secure connection with a server and includes information about the client's capabilities and preferences for the connection.

The content of the `ClientHello` message typically includes the following information:

1. The highest version of the TLS protocol that the client supports.

2. A list of cipher suites that the client supports, which are used to encrypt and decrypt data exchanged between the client and server.

3. A list of compression methods that the client supports.

4. A random value that is generated by the client and used to _generate session keys_ for the connection.

5. A list of extensions that provide additional information about the client's capabilities and preferences, such as the maximum fragment length the client can receive or whether the client supports server name indication (SNI) for virtual hosting.


The ClientHello message is a critical part of the TLS handshake process, as it allows the server to determine the appropriate TLS version, cipher suite, and other settings to use for the connection based on the client's capabilities and preferences.

## what are the available cipher suites

The available cipher suites in TLS depend on the version of TLS being used and the specific implementation of the TLS protocol. Generally, a cipher suite is a combination of cryptographic algorithms that are used to establish a secure connection between a client and server.

The TLS 1.2 and earlier versions support a range of cipher suites that use different combinations of encryption algorithms, key exchange algorithms, and message authentication codes (MACs). These cipher suites include:

RSA-based cipher suites, which use RSA for key exchange and digital signatures.
Diffie-Hellman-based cipher suites, which use the Diffie-Hellman key exchange algorithm.
Elliptic Curve-based cipher suites, which use elliptic curve cryptography (ECC) for key exchange and digital signatures.
Anonymous cipher suites, which do not authenticate the client or server
Cipher suites that use the Advanced Encryption Standard (AES) for symmetric encryption and HMAC for message authentication.
In TLS 1.3, the available cipher suites have been significantly reduced, and the protocol only includes a limited number of cipher suites that use modern cryptographic algorithms, such as AES-GCM and ChaCha20-Poly1305, for encryption and authentication. The TLS 1.3 cipher suites also use the Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm by default.

The available cipher suites can vary depending on the specific TLS implementation being used, and some cipher suites may be disabled or deprecated due to security vulnerabilities or weaknesses. It's essential to keep the TLS implementation up-to-date and use only secure cipher suites to ensure the highest level of security for the connection.

## what are available compression methods
Compression methods in TLS are used to compress the plaintext data before it is encrypted and transmitted over the network. Compression can help to reduce the amount of data that needs to be transmitted, which can improve the performance of the connection.

However, compression can also introduce security vulnerabilities, as it may make it easier for an attacker to perform attacks like the CRIME or BREACH attacks, which exploit weaknesses in the compression algorithm to steal sensitive data.

As a result, most modern TLS implementations do not support compression by default, and the available compression methods are often limited to "null" (i.e., no compression). In TLS 1.3, compression has been completely removed.

In earlier versions of TLS, the available compression methods include:

Null compression: This method does not compress the data and is equivalent to no compression.
Deflate compression: This method uses the Deflate algorithm to compress the data. However, this method is susceptible to the CRIME and BREACH attacks and is generally not recommended.
It's important to note that compression should be used with caution in TLS, and it's generally recommended to disable compression entirely to avoid potential security vulnerabilities.



## how is the random value generated to be used as session key
In TLS, a random value is generated by both the client and server during the TLS handshake process. This random value is used to derive the session keys that are used for the encryption and decryption of the data exchanged between the client and server.

The random value generated by the client is included in the ClientHello message, and the random value generated by the server is included in the ServerHello message. These random values are combined with other information exchanged during the handshake process to generate the session keys.

The session keys are derived using a process called the key derivation function (KDF). The KDF takes the random values generated by the client and server, along with other parameters such as the premaster secret and the cipher suite, and produces the session keys that are used for encryption and decryption.

The session keys are typically different for each connection, ensuring that each connection has a unique set of keys that are used exclusively for that connection. This helps to prevent attacks that may be possible if the same keys are used for multiple connections.

The use of random values to derive the session keys helps to ensure the security of the connection, as an attacker would need to guess the random values used in order to derive the session keys and decrypt the data exchanged between the client and server.


## what is the destination mac address during tls handshake with google.com
The destination MAC address during the TLS handshake with google.com would depend on the network topology and the specific devices involved in the communication.

During the TLS handshake, the client and server exchange messages over the internet using the IP protocol. The client sends the initial ClientHello message to the server using the server's IP address, and the server responds with a ServerHello message sent back to the client's IP address.

The MAC addresses used in the communication are typically determined by the network devices involved in the communication, such as routers, switches, or network interface cards (NICs). These devices use the MAC addresses to forward the packets to the appropriate destination on the local network.

In general, the destination MAC address during the TLS handshake with google.com would be the _MAC address of the next hop network device_, such as the router or gateway that connects the client to the internet. _The MAC address of the destination server, such as google.com, would not be used until after the TLS handshake is completed and the client and server begin exchanging application data._

## explain wiresharl tlsv1.3
```bash
    Flags: 0x40, Don't fragment
    0... .... = Reserved bit: Not set
    .1.. .... = Don't fragment: Set
    ..0. .... = More fragments: Not set
```

The Wireshark capture you provided appears to show a single flag that is set: the "Don't fragment" flag, which has a value of 1 in the second bit position (i.e., bit 14).

This flag is set in the **IP header** of the captured packet, and indicates that the packet should not be fragmented as it is transmitted over the network. _If the packet is too large to be transmitted without fragmentation, it will be dropped and an ICMP message will be sent back to the sender indicating that fragmentation is required._

The other two bits shown in the capture are not set: the "Reserved bit" is set to 0 in the first bit position, and the "More fragments" bit is set to 0 in the third bit position. These bits do not have any significance in this case since the "Don't fragment" bit is the only flag that is set.


## what is packet fragmentation
Packet fragmentation is a process in which large IP packets are divided into smaller fragments in order to be transmitted over a network that has a smaller maximum transmission unit (MTU). The MTU is the largest size of packet that can be transmitted over a network without being fragmented.

When a packet is too large to be transmitted over a network without fragmentation, it is divided into smaller fragments by the sending device. Each fragment contains a portion of the original packet, along with a header that contains information about the fragment and its position within the original packet.

The fragments are transmitted individually over the network, and are reassembled into the original packet by the receiving device. The receiving device uses the information in the fragment headers to determine the correct order of the fragments and to reassemble them into the original packet.

Packet fragmentation can introduce some additional overhead and complexity into the network communication process. In some cases, it may also introduce security vulnerabilities, as attackers may be able to exploit weaknesses in the fragmentation process to disrupt network communication or to perform other types of attacks. As a result, some network protocols and devices may avoid packet fragmentation altogether by setting the "Don't fragment" flag in packet headers, _which causes packets that are too large to be dropped rather than fragmented._

## why does my client communicate with google.com using tls1.2 then use tls1.3 shouldn't it use 1.3 always as is the highest ?
It's possible for a client to communicate with a server using different versions of the TLS protocol during a single session, if both the client and server support multiple versions of TLS.

In your example, it's possible that the client initially negotiated the TLS 1.2 protocol during the initial handshake with the server, and later negotiated a switch to the newer TLS 1.3 protocol after both client and server agreed to use it. This could happen for various reasons, such as the client initially proposing TLS 1.2 as the preferred protocol, or the server being configured to prefer TLS 1.2 for some reason.

It's worth noting that the choice of TLS protocol version can depend on various factors, such as the level of security needed for the connection, the capabilities of the client and server, and the availability of TLS implementations that support the desired protocol version. In general, it's recommended to use the latest TLS protocol version that both client and server support, as it typically offers the strongest security and the latest features. However, in some cases, backwards compatibility or other factors may require the use of an older protocol version.
